package main

import (
	"bufio"
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"pm.cn.tuwien.ac.at/ipfix/ipfix"
)

func main() {
	var src, spec *os.File
	var err error
	ext := ".iespec"
	if len(os.Args) == 2 && os.Args[1] == "xml" {
		ext = ".xml"
	}
	if file, ok := os.LookupEnv("GOFILE"); !ok {
		log.Panicln("Need environment variable GOFILE. Did you use go generate?")
	} else {
		if src, err = os.OpenFile(file, os.O_RDWR, 0666); err != nil {
			log.Panicln("Couldn't open input file", file, err)
		}
		if spec, err = os.Open(file[:len(file)-3] + ext); err != nil {
			log.Panicln("Couldn't open input file", file, err)
		}
	}
	var line = make([]byte, 4096)
	var current []byte
	var n int
	var pos, ret, tmp int64
	// Search for //go:generate
	for {
		pos += int64(n)
		tmp = 0
		current = line[0:cap(line)]
		n, err = src.Read(current)
		if err == io.EOF {
			log.Panicln("File must contain //go:generate")
		}
		current = current[0:n]
		switch ret {
		case 0:
			comment := bytes.Index(current, []byte("//go:generate"))
			if comment == -1 {
				continue
			}
			current = current[comment:]
			tmp += int64(comment)
			ret = 1
			fallthrough
		case 1:
			le := bytes.IndexByte(current, '\n')
			if le == -1 {
				continue
			}
			pos += int64(le) + 1 + tmp
			goto FOUND
		}
	}
FOUND:
	if err = src.Truncate(pos); err != nil {
		log.Panicln(err)
	}
	if _, err = src.Seek(0, 2); err != nil {
		log.Panicln(err)
	}
	wr := bufio.NewWriter(src)
	wr.WriteString(`
// GENERATED BY COMMAND ABOVE; DO NOT CHANGE!

import "pm.cn.tuwien.ac.at/ipfix/ipfix"

func init() {
`)
	cb := func(ie ipfix.InformationElement) {
		fmt.Fprintf(wr, "	ipfix.RegisterInformationElement(%#v)\n", ie)
	}
	if len(os.Args) == 2 && os.Args[1] == "xml" {
		xmlspec(spec, cb)
	} else {
		iespec(spec, cb)
	}
	wr.WriteString(`}
`)
	wr.Flush()
	src.Close()
	spec.Close()
}

func iespec(spec *os.File, cb func(ipfix.InformationElement)) {
	rd := bufio.NewScanner(spec)
	for rd.Scan() {
		cb(ipfix.MakeIEFromSpec(rd.Bytes()))
	}
}

func xmlspec(spec *os.File, cb func(ipfix.InformationElement)) {
	type Record struct {
		XMLName   xml.Name `xml:"record"`
		Name      string   `xml:"name"`
		DataType  []byte   `xml:"dataType"`
		ElementID int      `xml:"elementId"`
	}
	dec := xml.NewDecoder(spec)
SEARCH_IES:
	for {
		if tok, err := dec.Token(); err != nil {
			log.Panic(err)
		} else {
			if tok, ok := tok.(xml.StartElement); ok {
				if tok.Name.Local == "registry" && len(tok.Attr) == 1 && tok.Attr[0].Name.Local == "id" && tok.Attr[0].Value == "ipfix-information-elements" {
					break SEARCH_IES
				}
			}
		}
	}
	var start xml.StartElement
SEARCH_FIRST_RECORD:
	for {
		if tok, err := dec.Token(); err != nil {
			log.Panic(err)
		} else {
			if tok, ok := tok.(xml.StartElement); ok {
				if tok.Name.Local == "record" {
					start = tok
					break SEARCH_FIRST_RECORD
				}
			}
		}
	}
NEXT_RECORD:
	for {
		var rec Record
		dec.DecodeElement(&rec, &start)
		rec.Name = strings.TrimSpace(rec.Name)
		rec.DataType = bytes.TrimSpace(rec.DataType)
		if rec.Name != "" && rec.ElementID != 0 && len(rec.DataType) != 0 &&
			string(rec.DataType) != "basicList" && string(rec.DataType) != "subTemplateList" && string(rec.DataType) != "subTemplateMultiList" {
			//SMELL: hardcoded iana stuff
			cb(ipfix.NewInformationElement(rec.Name, 0, uint16(rec.ElementID), ipfix.NameToType(rec.DataType), 0))
		}
		for {
			if tok, err := dec.Token(); err != nil {
				log.Panic(err)
			} else {
				switch t := tok.(type) {
				case xml.StartElement:
					if t.Name.Local == "record" {
						start = t
						continue NEXT_RECORD
					}
					if t.Name.Local == "registry" {
						goto FINISHED
					}
				case xml.EndElement:
					if t.Name.Local == "registry" {
						goto FINISHED
					}
				}
			}
		}
	}
FINISHED:
}
